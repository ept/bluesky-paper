\documentclass[sigconf,review]{acmart}
\setcopyright{none}

\begin{document}
\title{Bluesky and the AT Protocol: Usable Decentralized Social Media}
\author{Martin Kleppmann}
\email{martin@kleppmann.com}
\orcid{0000-0001-7252-6958}
\affiliation{%
  \institution{TU Munich}
  \city{Munich}
  \country{Germany}
}

\author{Paul Frazee} % paul@blueskyweb.xyz
\author{Jake Gold} % jake@blueskyweb.xyz
\author{Jay Graber} % jay@blueskyweb.xyz
\author{Daniel Holmgren} % daniel@blueskyweb.xyz
\affiliation{\institution{Bluesky, PBC}\country{United States}}
\author{Devin Ivy} % devin@blueskyweb.xyz
\author{Jeromy Johnson} % why@blueskyweb.xyz
\author{Bryan Newbold} % bryan@blueskyweb.xyz
\author{Jaz Volpert} % jaz@blueskyweb.xyz
\affiliation{\institution{Bluesky, PBC}\country{United States}}

\begin{abstract}
    Bluesky is a new social network built upon the AT Protocol, a decentralized foundation for public social media.
    It was launched in private beta in February 2023, and has grown to over 1.5 million registered users in the following 9 months.
    In this paper we introduce the architecture of Bluesky and the AT Protocol, which is inspired by the web itself, but modernized to include streams of real-time updates and cryptographic authentication.
    We explain how the technical design of Bluesky is informed by our goals: to enable decentralization by having multiple interoperable providers for every part of the system; to make it easy for users to switch providers; to give users agency over the content they see; and to provide a simple user experience that does not burden users with complexity arising from the system's decentralized nature.
    The system's openness allows anybody to contribute to content moderation and community management, and we invite the web research community to use Bluesky as a dataset and testing ground for new approaches in social media moderation.
\end{abstract}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10002951.10003260.10003282.10003292</concept_id>
       <concept_desc>Information systems~Social networks</concept_desc>
       <concept_significance>500</concept_significance>
   </concept>
   <concept>
       <concept_id>10003033.10003106.10003114.10003118</concept_id>
       <concept_desc>Networks~Social media networks</concept_desc>
       <concept_significance>500</concept_significance>
   </concept>
   <concept>
       <concept_id>10003456.10003457.10003490.10003507.10003508</concept_id>
       <concept_desc>Social and professional topics~Centralization / decentralization</concept_desc>
       <concept_significance>300</concept_significance>
   </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Social networks}
\ccsdesc[500]{Networks~Social media networks}
\ccsdesc[300]{Social and professional topics~Centralization / decentralization}

\keywords{social media, decentralization, federation, web architecture}
\maketitle

\section{Introduction}

Over the last two decades, social media services have evolved from a fun curiosity into a cornerstone of civic life~\cite{Barabas:2017}.
This development has been accompanied by increasing unease that mainstream ``digital town squares'', such as Twitter/X or Facebook, are under the control of a single corporation, and may change their policies on the whim of their leaders~\cite{Yeung:2023}.
Their operations are opaque (e.g.\ regarding which content is recommended to users), and their users lack agency over their user experience.
As a result, there has been increasing interest in decentralized social networks, of which the \emph{fediverse} around the ActivityPub protocol~\cite{ActivityPub} and the Mastodon software~\cite{Mastodon} is perhaps the best known (we review a selection of decentralized social networks in Section~\ref{sec:related-work}).

However, decentralization also introduces new challenges.
For example, in the case of Mastodon, a user needs to choose a server when creating an account.
This choice is significant because the server name becomes part of the username; migrating to another server implies changing username, and preserving one's followers during such a migration requires the cooperation of the old server.
If a server is shut down without warning, accounts on that server cannot be recovered~-- a particular risk with volunteer-run servers.
In principle, a user can host their own server, but only a small fraction of social media users have both the technical skills and the inclination to do so.

The distinction between servers in Mastodon introduces complexity for users that does not exist in centralized services.
For example, a user viewing a thread of replies in the web interface of one server may see a different set of replies compared to viewing the same thread on another server, because a server only shows those replies that it knows about~\cite{Adida:2022}.
As another example, when viewing the web profile of an account on another server, clicking the ``follow'' button does not simply follow that account; instead, the user needs to enter the hostname of their own server and be redirected to a URL on their home server before they can follow the account.
In our opinion, it is undesirable to burden users with such complexity arising from the federated architecture.

In this paper we introduce the \emph{AT Protocol} (atproto), a decentralized foundation for social networking, and \emph{Bluesky}, a Twitter-style social app built upon it.
A core design goal of atproto and Bluesky is to enable a user experience of the same or better quality as centralized services, while being open and decentralized on a technical level.
We introduce the user-facing features of Bluesky in Section~\ref{sec:product}, and in Section~\ref{sec:architecture} we explain the underlying systems architecture.
The AT Protocol is designed such that for every part of the system there are multiple competing operators providing interoperable services, making it easy to switch from one provider to another.

Decentralization alone is not able to solve some of the thorniest problems of social media, such as misinformation, harassment, and hate speech.
However, by opening up the internals of a service to contributors who are not employees of a particular company, decentralization can enable a marketplace of approaches to these problems.
For example, Bluesky allows anybody to create custom feeds that can apply arbitrary filtering and content selection methods, and custom client software can access all features of the ``official'' app, including moderation tools.
Our hope is that this architectural openness will enable communities to develop their own approaches to managing problematic content, without depending on a centralized service operator to implement these features for them.

For example, researchers wanting to identify disinformation campaigns can easily get access to all content being posted, the social graph, and user profiles on Bluesky.
If they are able construct an algorithm to label suspected disinformation, they can publish their labels in real time for use by other parts of the system, such as custom feed generators or client apps.
One goal of this paper is therefore to bring Bluesky and the AT Protocol to the attention of researchers working on such algorithms, and to invite them to use the rapidly growing dataset of Bluesky content as a basis for their work.

\section{The Bluesky Social App}\label{sec:product}

Bluesky presents itself to users as a straightforward microblogging application in the style of Twitter/X (see Figure~\ref{fig:home-feed}).
The ``official'' client app is available on iOS, Android, and the web; several independently developed client apps are also available, such as Graysky and deck.blue. % TODO: links to those apps
Users can make public posts containing up to 300 characters of text, and up to four images, and they can interact with posts by replying, reposting, or liking.
A user can also follow other users, and the default feed shows posts by accounts that the user is following in reverse chronological order.
There are also alternative feeds that show content on various topics, without the user needing to follow the poster (see Section~\ref{sec:feeds}), which helps users discover each other.

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{home-feed.png}
    \Description{A Twitter-like feed of short posts. At the top is a feed selector, in which the default ``Following'' feed is active.}
    \caption{Screenshot of the Bluesky home screen.}
    \label{fig:home-feed}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{user-growth.pdf}
    \Description{An exponential growth curve, approximately doubling every month, starting at 55k in May 2023 and exceeding 1.3M in October 2023.}
    \caption{Number of registered Bluesky users from May to October 2023.}
    \label{fig:user-growth}
\end{figure}

Bluesky launched an invite-only beta release in February 2023, and has grown to over 1.5~million registered users in October 2023, as shown in Figure~\ref{fig:user-growth}.
At the time of writing, an invitation code is required to create an account, and codes are available through a waitlist or from an existing user.
Such control over user signups may seem contradictory for a supposedly open and decentralized network, but it has been necessary to limit the load on our infrastructure and to keep abuse at a manageable level.
We intend to remove the need for invite codes in early 2024.

Bluesky, PBC (a public-benefit corporation) develops the official client app and operates the core services; the client and several server-side components are open source under the MIT license~\cite{BlueskyGithub}.
The protocols they use are defined by open specifications~\cite{AtProtoSpecs}.
Several parts of the system, such as feed generators (Section~\ref{sec:feeds}) and various alternative clients~\cite{AtProtoClients} are developed and operated by independent third parties.

\subsection{Moderation Features}\label{sec:moderation}

Bluesky has several moderation mechanisms for managing unwanted content:
\begin{description}
    \item[Content filtering:] Automated systems label potentially problematic content (such as images of a sexual or violent nature, posts promoting hate groups, or spam), and the app's preferences allow users to choose whether to show or hide content in each of these categories in their feeds.
    \item[Mute:] A user can mute specific accounts or threads, which hides the muted content from their own feeds and notifications. The content continues to be visible to other users, and the target does not know that they were muted. A user can also publish a mutelist of accounts, and other users can subscribe to that list, which has the same effect as if they individually muted all of the accounts on the list.
    \item[Block:] One user can block another, which prevents all future interactions (such as mentions, replies, or reposts) between those accounts in addition to muting.
    \item[Takedown:] Users can report content that violates the terms of service to server operators, and the operators can take down violating posts or accounts.
    \item[Custom feeds:] While the aforementioned mechanisms provide negative moderation (helping users avoid content they do not want to see), feed generators (see Section~\ref{sec:feeds}) can actively select high-quality content.
\end{description}

Additional moderation mechanisms are under discussion~\cite{Moderation}.

\subsection{User Handles}\label{sec:handles}

Like on Twitter, a Bluesky user has two names: the \emph{display name} can be almost any string, and the \emph{handle} needs to uniquely identify a user.
A handle, prefixed with an @ sign, is used to mention another user in a post.
Examples can be seen in Figure~\ref{fig:home-feed} (the display name is in bold, and the handle is in a smaller font and lighter color).

The need for handles to be unique creates challenges in decentralized systems, since it requires an authority that determines which handle is assigned to which user.
Mastodon's approach is to include the server name in the handle, which makes it difficult to move to another server.
An alternative would be to use a blockchain-based naming system, such as the Ethereum Name System (ENS)~\cite{ENS}; this has the disadvantage of requiring the user to buy cryptocurrency in order to create an account, which we wanted to avoid.

Instead, Bluesky and atproto use DNS domain names as handles.
If a user already owns a domain name, they can claim it as their Bluesky handle by adding a DNS record or by hosting a file under a \texttt{.well-known} HTTPS URL on that domain~\cite{DomainHandle}.
Users can also buy a new domain name within Bluesky, via a partnership with a domain registrar~\cite{PurchaseDomain}.
Alternatively, users can sign up for a subdomain of \texttt{.bsky.social} for free.

Using DNS domain names as handles has several advantages:
\begin{itemize}
    \item We leverage the existing infrastructure of ICANN, registrars, and name servers, including for example the dispute resolution procedures for trademarks.
    \item Domain names are a well-known concept even among non-technical users, and they are short and simple.
    \item A user can move to a different server without changing their handle (see Section~\ref{sec:identity}).
    \item Users do not need to host their own server to use their own domain name; a DNS record requires only a one-time setup and no ongoing maintenance.
    \item For organizations and people that already have a well-known domain name, using that name makes it easy for users to check that their Bluesky account is genuine. For example, the New York Times' handle is \texttt{@nytimes.com}.
    \item An organization can easily allow their staff to demonstrate their affiliation by granting them handles that are subdomains of the organization's main domain name (comparable to institutional email addresses). For example, a journalist's handle may indicate that they are at a particular news organization.
    \item Providers wanting to offer free subdomains can do so at very little cost.
\end{itemize}

\subsection{Custom Feeds and Algorithmic Choice}\label{sec:feeds}

Several decentralized social networks choose to offer only a reverse-chronological feed of posts from accounts the user is following~-- a backlash against the opaque content recommendation algorithms employed by mainstream centralized social networks.
For example, Mastodon advertises itself as having ``no algorithms or ads to waste your time''~\cite{Mastodon}.

Our belief is that the problem lies not with algorithms \emph{per se}, but rather with centrally controlled, opaque algorithms that remove user agency and prioritize user engagement over all else, e.g.\ by promoting controversial posts.
Good recommendation algorithms can help users discover content that is relevant to them and find new accounts to follow~-- especially important for new users who are not yet following many accounts.
They are also helpful for surfacing content on a particular topic, whereas following a user means seeing all of their posts, which might be on a mixture of topics, not all necessarily interesting to all followers.

Bluesky, PBC offers a selection of feed generation algorithms of its own, and also allows anybody to create their own feed generator~\cite{CustomFeeds}.
The goal is to offer an open and diverse ``marketplace of algorithms'' in which communities can adapt the system to suit their needs, and users have more agency over how they spend their time and attention~\cite{AlgorithmicChoice}.
Section~\ref{sec:labeling} explains how feed generators work.
TODO: how many custom feeds have been created to date?

In Figure~\ref{fig:home-feed}, a selection of bookmarked feeds is given at the top of the screen; in this example, the selected ``Following'' feed is the default reverse-chronological timeline, while ``Week Peak Feed'' (network-wide posts with many likes from the last week) and ``Birds!'' (photos and posts from birdwatchers) are third-party feeds.
A feed generator can use arbitrary criteria to select its content.
For example, the birdwatching feed uses manual review of accounts in combination with a \#birds hashtag or a feather emoji character in posts to identify posts to include.
Alternative approaches, such as machine learning algorithms, are equally possible.

\begin{figure*}
    \centering
    \includegraphics[width=\linewidth]{architecture.pdf}
    \Description{Client apps send posts, likes, etc. to the user's home PDS. A stream of records from each PDS is consumed by the BGS, and aggregated to form the firehose. The firehose is consumed by the Bluesky App View as well as labelers and feed generators. PDSes read from the App View to obtain threads of replies, like counts, etc. Bluesky, PBC currently hosts several PDSes, the BGS, the App View, and some of the labelers and feed generators. The Bluesky App View also pulls data from external labelers and feed generators. Other providers can set up alternative PDSes, aggregators, and app views if they wish (including app views for social modes other than microblogging).}
    \caption{The main services involved in providing Bluesky, and data flows between them. Icons from Flaticon.com.}
    \label{fig:indexing}
\end{figure*}

% Icons used:
% https://www.flaticon.com/free-icon/browsing_2975669
% https://www.flaticon.com/free-icon/mobile_6300115
% https://www.flaticon.com/free-icon/segmentation_6012134
% https://www.flaticon.com/free-icon/server_689360
% https://www.flaticon.com/free-icon/simplify_5271304
% https://www.flaticon.com/free-icon/product-development_4229803
% https://www.flaticon.com/free-icon/carousel_9893850
% https://www.flaticon.com/free-icon/virality_11940519
% https://www.flaticon.com/free-icon/content-plan_11940521
% https://www.flaticon.com/free-icon/blogger_3893160
% https://www.flaticon.com/free-icon/online-learning_12641520
% https://www.flaticon.com/free-icon/working_5654681

\section{The AT Protocol Architecture}\label{sec:architecture}

Bluesky is the social app with the features explained in Section~\ref{sec:product}, while the AT Protocol is the underlying decentralized foundation.
We maintain this separation because the AT Protocol is designed to support multiple \emph{social modes}, not just Bluesky.
For example, besides a Twitter-style microblogging app, atproto could also be used to implement Reddit-style forums, long-form blogs with comments, or domain-specific social applications such as link sharing or book reviews.
The same user identity, social graph, and user data storage servers can be shared between all of these apps.

The data types and concepts for a particular social mode are defined by a \emph{lexicon}, which specifies the schema of the data and the request endpoints involved in providing that social mode~\cite{AtProtoSpecs}.
At the moment, the \texttt{com.atproto} lexicon defines the core AT Protocol concepts such as user identity (Section~\ref{sec:identity}), and the \texttt{app.bsky} lexicon defines the microblogging mode.
Anyone can define a new lexicon, allowing new social modes to coexist alongside the Bluesky social app on a shared infrastructure.

The biggest constraint for new social modes is that atproto is designed for content that users intend to make publicly available.
In particular, Bluesky user profiles, posts, follows, and likes are all public.
Blocking actions are also currently public; however, we are investigating mechanisms for making these private~\cite{PrivateBlocks}.
At present, Bluesky does not support direct messages, which would need to be private and encrypted.
Only a small amount of Bluesky user state is currently private: any muted accounts and threads, notifications, and their read/unread status.

\subsection{User Data Repositories}\label{sec:repos}

All data that a user wishes to publish is added to their \emph{repository}, which stores a collection of \emph{records}.
Whenever a user performs some action~-- making a post, liking another user's post, following another user, etc.~-- that action becomes a record in their repository.
The structure of records is defined by the lexicon, and a repository may contain a mixture of records from several different lexicons, representing user actions in different social modes.

Each user account has one repository, and it contains all of the actions they have ever performed, minus any records they have explicitly deleted.
A \emph{Personal Data Server (PDS)} hosts the user's repository and makes it publicly available as a web service; we discuss PDSes in more detail in Section~\ref{sec:pds}.

A user only updates their own repository; for example, if user $A$ follows user $B$, this results only in a follow record in user $A$'s repository, and no change to $B$'s repository.
To find all followers of user $B$ requires indexing the content of all repositories.
This design decision is similar to the way hyperlinks work on the web: it is easy to find all the outbound links from a web page at a given URL, but to find all the inbound links to a page requires an index of the entire web, which is maintained by web search engines.

The \emph{AT} in atproto stands for \emph{Authenticated Transfer}, which reflects the fact that repositories are cryptographically authenticated.
The records in a repository are organized into a \emph{Merkle Search Tree} (MST), a type of Merkle tree that remains balanced, even as records are inserted or deleted in arbitrary order~\cite{Auvolat:2019}.
After every change to a repository, the root hash of the MST is signed; the public verification key for this signature is part of the user identity described in Section~\ref{sec:identity}.
This enables an efficient cryptographic proof that a given record appears within a given user's repository.

\subsection{Personal Data Servers (PDS)}\label{sec:pds}

A PDS allows anybody to query the content of the repositories that it hosts via a HTTP API.
Moreover, a PDS provides a real-time stream of updates for the repositories it hosts.
Indexers (see Section~\ref{sec:indexing}) subscribe to this stream in order to find out about new or deleted records (posts, likes, follows, etc.) with low latency.
This architecture is illustrated in Figure~\ref{fig:indexing}.

Hosting a PDS for a small number of users requires only small computing resources, even if those users have a large number of followers.
Users who wish to self-host their own PDS can therefore do so on a cheap virtual machine in the cloud, or even on a Raspberry Pi connected to their home internet router.
However, we expect that most users will sign up for an account on a shared PDS run by a professional hosting provider~-- either Bluesky, PBC, or another company.

Compared to choosing a Mastodon server, the user's choice of PDS hosting provider is fairly inconsequential.
The PDS URL is internal to the system, and is not normally visible to users.
It makes no difference whether two users are on the same PDS or different PDSes, since interaction between users goes via the indexing infrastructure in any case.
A user can migrate from one PDS to another by simply copying their repository to the new PDS, and pointing their account ID at the new PDS URL (see Section~\ref{sec:identity}).
Even if a PDS shuts down without warning, users can upload a backup of their repository to a new PDS, and thus recover their account without losing any of their posts or their social graph.

PDS operators will generally want to perform some basic moderation by deleting any illegal content hosted on their servers.
However, PDS-level moderation is much less important than server-level moderation in Mastodon, because in atproto, the primary moderation role is taken on by seperate actors in the system~-- the labelers and feed generators (see Section~\ref{sec:labeling}).
This allows different sets of people to offer server hosting and moderation services, respectively; we believe this separation is valuable since operating a server and moderating a community require largely disjoint skill sets.

At the time of writing, Bluesky's indexing infrastructure (see Section~\ref{sec:indexing}) only indexes repositories on PDS instances hosted by Bluesky, PBC itself; like invitation codes, this limitation exists to limit infrastructure load and abuse problems during the private beta period.
In that sense, Bluesky is not yet fully decentralized.
Support for third-party PDS operators is already implemented and enabled in Bluesky's \emph{sandbox} (testing) environment, and a PDS implementation suitable for self-hosting is already open source~\cite{BlueskyGithub}.
We plan for the Bluesky indexing infrastructure to begin indexing repositories on other PDS operators (indicated by dashed arrows in Figure~\ref{fig:indexing}) in early 2024.

\subsection{Indexing Infrastructure}\label{sec:indexing}

On the web, websites are crawled and indexed by search engines, which then provide web-wide search and discovery features that the websites alone cannot provide.
The AT Protocol is inspired by this architecture: the repositories hosted by PDSes are analogous to websites, and the indexing infrastructure is analogous to a search engine.
User repositories are primary data (the ``source of truth''), and the indexes are derived from the content of the repositories.

At the time of writing, most of Bluesky's indexing infrastructure is operated by Bluesky, PBC (indicated by a shaded area in Figure~\ref{fig:indexing}).
However, the company does not have any privileged access: since repositories are public, anybody can crawl and index them using the same protocols as our systems use.
Client apps can switch to reading from a different index, or use a combination of multiple indexes.

While operating a small PDS is designed to be cheap, operating an indexer that ingests the entire network requires greater computing resources.
We therefore expect that there will be fewer hobbyist indexers than self-hosted PDSes.
Nevertheless, as Bluesky grows, there are likely to be multiple professionally-run indexers for various purposes.
For example, a company that performs sentiment analysis on social media activity about brands could easily create a whole-network index that provides insights to their clients.

The indexing infrastructure operated by Bluesky, PBC is illustrated in Figure~\ref{fig:indexing}.
It is composed of multiple services that have integration points for external services.

\subsubsection{Big Graph Service (BGS)}\label{sec:bgs}

The first component is the \emph{Big Graph Service} (BGS), which crawls the user repositories on all known PDSes and consumes the streams of updates that they produce.
BGS checks the signatures and Merkle tree proofs on updates, and maintains its own replica of each repository.
From this information, BGS creates the \emph{firehose}: an aggregated stream of updates that notifies subscribers whenever records are added or deleted in any of the known repositories.

The firehose is publicly available.
Consuming the firehose is an easier way of building an index over the whole network, compared to directly subscribing to the source PDSes, since the BGS performs some initial data cleaning such as discarding malformed updates and filtering out high-volume spam.
The firehose can optionally include Merkle proofs and signatures along with records, allowing subscribers to check that they are authentic.

BGS does not interpret or index the records in repositories, but simply stores and forwards them.
Any developers wanting to create a new social mode on top of atproto can define a new lexicon with new record types, and these records can be stored in existing repositories and aggregated in the firehose without requiring any changes to the BGS.

\subsubsection{The App View}\label{sec:appview}

The App View is a service that consumes the firehose, and processes the records belonging to the Bluesky social app (the \texttt{com.atproto} and \texttt{app.bsky} lexicons).
For example, the App View counts the number of likes on every post, and it collects the set of replies to a particular post.
The App View also maintains the set of followers for each user, and constructs the timeline containing the posts by the accounts that each user is following.
Finally, it offers a web service through which this information can be queried.

To display this information in the user's client app, the client queries the user's own PDS, which then fetches the neccessary data from the App View.
The PDS personalizes the information from the App View to include details that are specific to the querying user, e.g.\ hiding posts from accounts that the user has muted, and indicating whether the user has already liked a given post.

The App View is also responsible for enforcing moderation controls; for example, if one user has blocked another, the App View drops any attempts by the blocked users to interact with each other.
If users are unhappy with the moderation rules applied by the App View operated by Bluesky, PBC, it is always possible for third parties to operate alternative App Views that index the same firehose and present the data in a different way.

If the AT Protocol is used to implement another social mode besides microblogging, that application will most likely require an App View service of its own, which can be hosted by anyone.
This service can then interpret and index the records in users' repositories in whatever way is required for that application.

\begin{figure*}
    \centering
    \includegraphics[width=\linewidth]{identity.pdf}
    \Description{Handle (e.g. nytimes.com) resolves to DID via DNS TXT record or HTTPS request. DID resolves to DID document via did:web or did:plc directory server.}
    \caption{A handle resolves to a DID, and a DID resolves to a DID document, which in turn references the handle, DID, and the user's public key. Icons from Flaticon.com.}
    \label{fig:identity}
\end{figure*}

% Icons used:
% https://www.flaticon.com/free-icon/dns_2333476
% https://www.flaticon.com/free-icon/fingerprint-scan_6692271
% https://www.flaticon.com/free-icon/folder_4883508

\subsection{Labelers and Feed Generators}\label{sec:labeling}

The BGS and App View aim to provide a mostly ``unopinionated'' service: they compute indexes over the records in repositories in a neutral way, without attempting to rank or classify content.
However, a good user experience also requires ``opinionated'' judgements for the purposes of content filtering (e.g.\ detecting sexually explicit images or spam) and curation (e.g.\ selecting posts on a particular topic).

The AT Protocol architecture seperates out the ``opinionated'' aspects of the system into separate services: \emph{labelers} and \emph{feed generators}.
These services typically take the firehose as their input.
Labelers produce a stream of judgements about content (e.g.\ ``this post is spam''), whereas feed generators return a list of post IDs they have selected for inclusion in a custom feed, as described in Section~\ref{sec:feeds}.
The output of labelers is consumed by App Views or PDSes in order to apply content filtering~\cite{Labeling}.
For a feed generator, an App View expands the post IDs into full posts before sending them to the client app of users who have subscribed to that feed.

Having labeler and feed generator services that are separate from App Views has several advantages:
\begin{itemize}
    \item Anyone can run such services, which enables a pluralistic ecosystem in which different parties may make different judgements about the same piece of content.
        Users, as well as the operators of App Views and PDSes, can decide whose judgements they want to trust, and it is easy for them to switch to alternative labeling and feed generation services if their current providers fail to meet their expectations.
    \item It becomes easier to set up alternative App View providers: since any App View can consume the publicly available output from labelers and feed generators, there is no need for each App View to develop its own content filtering infrastructure.
        Having alternative App Views besides the one operated by Bluesky, PBC, is important for a healthy, decentralized marketplace.
\end{itemize}

TODO: feed generator hosting services, and tools such as \url{https://github.com/skyfeed-dev/skyfeed-me}

TODO: How is the output of labelers and feed generators consumed? Does it go to the user's PDS, or to the App View?

\subsection{User Identity}\label{sec:identity}

As explained in Section~\ref{sec:handles}, Bluesky and atproto rely on DNS domain names as user handles.
This has the advantage that any number of identity providers can coexist in the system: Bluesky, PBC operates an identity provider that allows users to register subdomains of \texttt{.bsky.social}, but the indexing infrastructure treats users with those handles identically to accounts with any other handle.

We want a user to be able to change their handle without affecting their social graph.
Therefore, when a record in user $A$'s repository indicates that $A$ is following $B$, that record must identify $B$ in a way that is more long-lived than specifying $B$'s handle.
For this reason, every Bluesky/atproto account has an immutable, unique identifier: a \emph{decentralized ID} or \emph{DID}, which is a URI starting with the prefix \texttt{did:}.
The record that $A$ follows $B$ then contains $B$'s DID.
DIDs are a recent W3C standard~\cite{DIDCore}.

Moreover, we want a user to be able to migrate to a different PDS without changing either their DID or their handle.
The DID specification provides a mechanism for \emph{resolving} a DID into a \emph{DID document}, a JSON document containing information about the user identified by that DID, as illustrated in Figure~\ref{fig:identity}.
In atproto, a DID document specifies (among other things) the handle of the user, the URL of their PDS, and the public key that is used to sign the Merkle tree root of their repository every time they add or delete a record.
To change their handle or their PDS, the user needs to update their DID document to the new value.

For a user to successfully claim a particular handle, they must have a bidirectional link between their DID and their domain name handle, as shown in Figure~\ref{fig:identity}:
\begin{itemize}
    \item A link from the handle to the DID is established either by storing the DID in a DNS TXT record on that domain name, or by returning the DID in response to a HTTPS request to a \texttt{/.well-known/} URL on that domain name~\cite{DomainHandle}.
    \item A link from the DID to the handle is established by including the handle in the DID document that is returned when the DID is resolved.
\end{itemize}

\subsubsection{Resolving DID documents}

The W3C DID specification~\cite{DIDCore} does not directly specify the mechanism for resolving a DID into a DID document.
Rather, the first substring after \texttt{did:} in a DID indicates the \emph{DID method}, and the specification of the DID method defines the protocol for obtaining the DID document.
Hundreds of DID methods have been defined~\cite{DIDMethods}, many of which are dependent on specific blockchains or other external systems.
To avoid atproto implementations having to support so many resolution methods, our services currently only accept DIDs based on either \texttt{did:web} (defined by the the W3C Credentials Community Group~\cite{did:web}) or \texttt{did:plc} (defined by ourselves for atproto~\cite{did:plc}).
Support for more DID methods might be added in the future.

The \texttt{did:web} method is very simple: the part of the DID after \texttt{did:web:} is a domain name, and the DID document is resolved by making a HTTPS request to a \texttt{/.well-known/} URL on that domain name (a path can optionally be included).
The security of a \texttt{did:web} identity therefore assumes that the web hosting provider for that domain is trusted, and also relies on trusting the TLS certificate authorities that may authenticate the HTTPS request.

\texttt{did:web} identities are therefore similar to domain name handles, with the difference that the name cannot be changed, since a DID is an immutable identifier.
This makes \texttt{did:web} appropriate for the identity of organizations that are already strongly linked to a particular domain name.
For most individual users, \texttt{did:plc} is more appropriate, since it allows the domain name handle to be changed.

\subsubsection{The did:plc DID method}

When a user creates an account on the Bluesky social app, they are by default assigned a DID of the form \texttt{did:plc:eclio37ymobqex2ncko63h4r}, where the string after the prefix \texttt{did:plc:} is the SHA256 hash of the initial DID document, truncated to 120 bits and encoded using base32~\cite{did:plc}.
A DID of this form can be resolved to the corresponding DID document by querying a server at \url{https://plc.directory/}, which is currently operated by Bluesky, PBC; in the future we plan to establish a consortium of independent operators that collectively provide the PLC directory service.

The PLC directory server is mostly untrusted because PLC DID documents are self-certifying.
If the DID document has not changed since its initial creation, it is easy to verify that a DID has been correctly resolved to a DID document by recomputing its hash.
To support changes to the DID document, the initial version of a user's DID document contains a public key that is authorized to sign a new version of the DID document.
Any new version of the DID document is only valid if it has been signed by the key in the previous version.
The directory server returns all DID document versions for a given DID, allowing anybody to check the chain of signatures.

If the directory server were to be malicious, it would not be able to modify any DID documents~-- it could only omit valid DID document versions from its responses, or fail to respond at all.
Moreover, if there were to be a fork in DID document history such that two correctly signed successor versions for some DID document exist, the directory server could choose which one of these forks to serve.
To mitigate the risk of such attacks, we anticipate that a future version of the PLC directory will use techniques from certificate transparency~\cite{Laurie:2014} to ensure that DID document updates form an append-only log.

\subsubsection{Authentication}

In principle, the cryptographic keys for signing repository updates and DID document updates can be held directly on the user's devices, e.g.\ using a cryptocurrency wallet, in order to minimize trust in servers.
However, we believe that such manual key management is not appropriate for most users, since there is a significant risk of the keys being compromised or lost.

The Bluesky PDSes therefore hold these signing keys custodially on behalf of users% in a hardware security module (HSM) % TODO: is this correct?
, and users authenticate themselves to their home PDS via username and password.
This provides a familiar user experience to users, and enables standard features such as password reset by email.
The AT Protocol does not make any assumptions about how PDSes authenticate their users, and other PDS operators are free to use different authentication methods.

\subsection{TODO}

How are images stored? When migrating an account to a new PDS, presumably images need to be moved along with the repo. Do viewers of an image fetch it from the PDS of the user who posted it, or from the App View?

How does a PDS operator take down a ToS-violating post within a repo? Do they directly modify the repo and sign a new commit? How would this work if the signing key is not held custodially by the PDS, but rather by a client-side wallet?

Do blocklists exist yet?

Are keys held custodially by a PDS actually stored in a HSM? Is this why the same key is currently shared by all users on the same PDS? How will the key management change as a result of the PDS 2.0 architecture and the use of dedicated hardware in multiple locations? Will PDS 2.0 servers have HSMs?

Are there push notifications? Which part of the system sends them?

Do we want to talk about some kind of robots.txt-like mechanism through which users can specify preferences regarding crawling and indexing?

Do we want to include some sort of discussion about business models? How do the operators of app views, labelers, etc.\ get paid?

Discussion of censorship resistance, separaration of speech and reach

Discussion of verifiable computaton? \url{https://blueskyweb.xyz/blog/3-6-2022-a-self-authenticating-social-protocol}

\section{Related Work}\label{sec:related-work}

TODO

Ecosystem review \url{https://gitlab.com/bluesky-community1/decentralized-ecosystem/-/blob/master/README.md}

\url{https://fed.brid.gy/docs#compare}

\url{https://activitypub.rocks/}

\url{https://github.com/lens-protocol/core}

\url{https://nostr.com/}
``the Nostr protocol powers Minds and Snort, among other decentralized social media''

\url{https://www.farcaster.xyz/}

\url{https://github.com/farcasterxyz/protocol/blob/main/docs/OVERVIEW.md}

\url{https://www.varunsrinivasan.com/2022/01/11/sufficient-decentralization-for-social-networks}

Matrix, IRC, RSS

\subsubsection{Scuttlebutt}

Secure Scuttlebutt (SSB) is a peer-to-peer social networking protocol~\cite{Scuttlebutt}; Manyverse~\cite{Manyverse} and Planetary~\cite{Planetary} are social applications built upon the SSB protocol.
It optionally uses relay servers called \emph{pubs} to store messages from peers that are offline, and to enable user discovery.
The client software downloads the feeds from accounts that the user is explicitly following, and from accounts followed by followed accounts (up to three hops by default).
This can require significant amounts of storage and bandwidth on the client.

Any messages from users outside of the third-degree network are not shown, which effectively limits the set of people who can mention or reply to a user to the third-degree network.
This deliberate design decision is intended to reduce moderation problems by prioritizing conversation between people who already know each other~\cite{ManyverseBluesky}.
In contrast, Bluesky/atproto are designed to allow anybody to talk to anybody else.
This requires more explicit moderation to manage unwanted content, but we believe it also enables serendipity and is a prerequisite for any ``digital town square''.

Since SSB is built upon append-only logs and gossip replication, it is not possible to delete content once it has been posted~\cite{SSBDeletion}.
User identity is tied to a cryptographic key on the user's device, requiring manual key management for moving to another device.
Posting from multiple devices is not possible, as sharing the same key between devices can make an account unrecoverable~\cite{SSBMultiDevice}.
A work-in-progress successor protocol to SSB, called PPPPP, is designed to address these issues~\cite{PPPPP}.

% for likes, the record is around 100 bytes, and the the MST tree stuff is anywhere from 1-4kb (depending on the repo and other randomness in the MST), usually averaging around 2.5Kb.
% https://github.com/bluesky-social/discuss/discussions/16#discussioncomment-7233086

\begin{acks}
TODO
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}
\end{document}
